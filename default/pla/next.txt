from random import shuffle, randint
import time
import json

previousId = getPreviousExerciseId()
if previousId : # bloque le bouton ->
    playIfUnplayed(previousId)

############ LOAD VARIABLE
timer = 300 # 13 * 60
startTime = load("startTime",time.time())
if time.time() - startTime > timer :
  startTime = time.time()
  save("startTime",startTime)
  save("indexUnique", indexUnique + 1)
  generateAndPlayExercise(getExerciseId(0,1), {"":indexUnique})

indexGroup = load("indexGroup",0)
indexUnique = load("indexUnique",0)

FULLSUCCESSTIMER = 15
TIMERATE = 15
FAILVALUE = 2
MINVALUE = 4
MAXVALUE = load("MAXVALUE",10)

size = 5
originalGlossaire = []

# charge le fichier nécessaire
if indexGroup > 3:
    indexGroup = 0
    
if indexGroup == 0:
  originalGlossaire = json.load(open('includes/glossaire.json','r'))
  MAXVALUE = len(originalGlossaire)
  save("sizeGlossaire", len(originalGlossaire))
  save("MAXVALUE",MAXVALUE)

elif indexGroup == 1:
  groupe = json.load(open('includes/definition.json','r'))

elif indexGroup == 2:
  groupe = json.load(open('includes/traduction.json','r'))

elif indexGroup == 3:
  groupe = json.load(open('includes/utilisation.json','r'))

stat = load("stat",{})
if stat == {} :
  for term in originalGlossaire :
    stat[term["term"]] = MINVALUE


# met à jour les données de stat
if previousId :
  exoData = getExerciseVariable(previousId,"stat")
  
  previousGroup = 3 if indexGroup == 0 else indexGroup - 1
  if exoData is None or exoData == {} and previousGroup != 0:
    stopActivity()
  else :
    platon_log(exoData)

  choix = getExerciseVariable(previousId,"choix")
  exoDuration = getExerciseVariable(previousId,"duration")

  if exoDuration is None and previousGroup != 0 :
    stopActivity()

  if choix == "Arrêter":
    stopActivity()

  if not exoData == {}:
    for key in exoData.keys():
      if exoData[key] == 1:
          if exoDuration < FULLSUCCESSTIMER:
              stat[key] += MAXVALUE
          else :
            stat[key] += max(MINVALUE, exoDuration // TIMERATE)
      else :
          stat[key] += FAILVALUE
  else :
    ok = 0
    sizeGlossaire = load("sizeGlossaire", 10)
    for key in stat.keys():
      stat[key] = stat.get(key) - 1
      if stat[key] >= MAXVALUE :
        ok += 1

    if ok == MAXVALUE :
      stopActivity()

stat = {k: v for k, v in sorted(stat.items(), key=lambda item: item[1])}


############ FUNCTION

def next_data_save(groupe,glossaireExo, size):
  """
  derniere chance pour sauver l'activitée, charge l'exo 0 du groupe qui doit avoir tout les termes
  """
  # prends un exercice 
  ExoNumber = 0
  # pour le ExoNumber
  exerciceData = {
      "title" : groupe[ExoNumber]['exercice']['title'],
      "instructions" : groupe[ExoNumber]['exercice']['instructions'],
      "questions":[],
  }
  count = 0 # arrête si trop de terme
  for question in groupe[ExoNumber]['exercice']['questions']:
      if question['term'] in glossaireExo:
          exerciceData["questions"].append(question)
          count += 1
      if size == count:
          break

  return ExoNumber,exerciceData


def next_data(groupe,strIndexGroup, glossaireExo, size):
  """
  Choisis aléatoirement un exercice dans le groupe et donne le glossaire réduit à quelques mots
  paramètres:
  - listes des exercices répartis dans leur groupe
  - index du groupe en cours en str pour utiliser comme clef de dictionnaire
  - le glossaire
  - le nombre de termes à extraire pour les exercices (On ne fait pas tous les termes en même temps)

  returns
  - le numéro de l'exercice dans le groupe.
  - les données de l'exercice filtrées pour correspondre au glossaire
  
  !!! ATTENTION AUX EXO QUI NE PEUVENT PAS PRENDRE TOUT LES MOTS !!! 
  """

  # prends un exercice 
  ExoNumber = randint(0,len(groupe) - 1)

  # pour le ExoNumber
  exerciceData = groupe[ExoNumber]["exercice"].copy()
  exerciceData["questions"] = []

  count = 0 # arrête si trop de terme
  for question in groupe[ExoNumber]['exercice']['questions']:
      if question['term'] in glossaireExo:
          exerciceData["questions"].append(question)
          count += 1
      if size == count:
          break

  if len(exerciceData["questions"]) == 0: # il n'y a pas assez de question, ont tente de charger le premier exercice du groupe est, on prie pour qu'il y ait des questions
    return next_data_save(groupe, glossaireExo, size)

  return ExoNumber,exerciceData


def get_Lst_glossaire(indexGroup,stat,glossaire, size):
  """
  donne la liste des termes du glossaire
  """
  # récupére le glossaire réduit à quelque mots
  if indexGroup == 0:
      glossaireExo = []
      keys = [key for key in stat.keys()]
      limit = min(size,len(keys))
      glossaireExo = [ keys[i] for i in range(0,limit)]
      save("glossaireExo", glossaireExo)

  else :
      glossaireExo = load("glossaireExo",None)
      if glossaireExo is None :
          raise ValueError("Erreur sur le glossaire")

  return glossaireExo


def next_exercice(indexGroup,glossaireExo,groupe,size):
  """
  renvoie le type d'exo à faire et le glossaire personnalisé
  paramètres :
  - index du groupe en cours
  - dictionnaire sur les statistiques des termes
  - glossaire original avec tous les termes
  - liste des exercices répartie dans leur groupe
  """
  # récupére un type d'exercice est les données nécessaires 
    allowed_template = {
    # groupe definition
    "definition_picker" : [0,3],
    "definition_emplacement" : [1],
    "definition_match" : [2],

    # groupe traduction
    "traduction_picker" : [0,4],
    "traduction_match" : [1,2,3],


    # groupe utilisation
    "utilisation_synonyme" : [0,1],
    "utilisation_phrase_trou_picker" : [2],
    "utilisation_phrase_ordre" : [3],
    #"utilisation_dialogue_theme_picker" : [4],
    "utilisation_erreur" : [4],
    "utilisation_vrai_faux" : [5]
}
  
  
  exoNumber,exerciceData = next_data(groupe,str(indexGroup), glossaireExo, size)

  choixTemplate = randint(0,len(groupe[exoNumber]["template"]) -1)  # index dans la liste des templates
  templateNumber = allowed_template[groupe[exoNumber]['template'][choixTemplate]]    # numéro du template choisis

  return templateNumber,exerciceData


def get_small_glossaire(glossaireExo, originalGlossaire):
  """
  recopie les informations de originalGlossaire pour les termes dans glossaireExo 
  """
  return [term for term  in originalGlossaire if term["term"] in glossaireExo]

############ CODE

glossaireExo = get_Lst_glossaire(indexGroup,stat,originalGlossaire, size)

save("indexGroup", indexGroup + 1)
#platon_log("before save " + str(stat))
save("stat",stat)
save("indexUnique", indexUnique + 1)
save("startTime",startTime)

if indexGroup == 0:
  exerciceData = get_small_glossaire(glossaireExo, originalGlossaire)
  generateAndPlayExercise(getExerciseId(0,0),{"data": exerciceData,"":indexUnique})
else :
  templateNumber,exerciceData = next_exercice(indexGroup,glossaireExo,groupe,size)
  generateAndPlayExercise(getExerciseId(indexGroup,templateNumber), {"data": exerciceData, "":indexUnique})